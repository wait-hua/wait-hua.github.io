[{"title":"reqwest源码学习","date":"2017-07-22T10:50:10.000Z","path":"2017/07/22/reqwest源码学习/","text":"最近的几个项目都用了reqwest，空闲时间看了下reqwest源码，覆上了自己理解的注释(文中@jch为个人注解)。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645/*! * Reqwest! A general purpose XHR connection manager * license MIT (c) Dustin Diaz 2015 * https://github.com/ded/reqwest */!function (name, context, definition) &#123; if (typeof module != 'undefined' &amp;&amp; module.exports) module.exports = definition() else if (typeof define == 'function' &amp;&amp; define.amd) define(definition) else context[name] = definition()&#125;('reqwest', this, function () &#123; var context = this if ('window' in context) &#123; var doc = document , byTag = 'getElementsByTagName' , head = doc[byTag]('head')[0] &#125; else &#123; var XHR2 try &#123; XHR2 = require('xhr2') &#125; catch (ex) &#123; throw new Error('Peer dependency `xhr2` required! Please npm install xhr2') &#125; &#125; var httpsRe = /^http/ , protocolRe = /(^\\w+):\\/\\// , twoHundo = /^(20\\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request , readyState = 'readyState' , contentType = 'Content-Type' , requestedWith = 'X-Requested-With' , uniqid = 0 , callbackPrefix = 'reqwest_' + (+new Date()) , lastValue // data stored by the most recent JSONP callback , xmlHttpRequest = 'XMLHttpRequest' , xDomainRequest = 'XDomainRequest' , noop = function () &#123;&#125; , isArray = typeof Array.isArray == 'function' ? Array.isArray : function (a) &#123; return a instanceof Array &#125; , defaultHeaders = &#123; 'contentType': 'application/x-www-form-urlencoded' , 'requestedWith': xmlHttpRequest , 'accept': &#123; '*': 'text/javascript, text/html, application/xml, text/xml, */*' , 'xml': 'application/xml, text/xml' , 'html': 'text/html' , 'text': 'text/plain' , 'json': 'application/json, text/javascript' , 'js': 'application/javascript, text/javascript' &#125; &#125; , xhr = function(o) &#123; // is it x-domain if (o['crossOrigin'] === true) &#123; var xhr = context[xmlHttpRequest] ? new XMLHttpRequest() : null if (xhr &amp;&amp; 'withCredentials' in xhr) &#123; return xhr &#125; else if (context[xDomainRequest]) &#123; return new XDomainRequest() &#125; else &#123; throw new Error('Browser does not support cross-origin requests') &#125; &#125; else if (context[xmlHttpRequest]) &#123; return new XMLHttpRequest() &#125; else if (XHR2) &#123; return new XHR2() &#125; else &#123; return new ActiveXObject('Microsoft.XMLHTTP') &#125; &#125; , globalSetupOptions = &#123; dataFilter: function (data) &#123; return data &#125; &#125; function succeed(r) &#123; var protocol = protocolRe.exec(r.url) protocol = (protocol &amp;&amp; protocol[1]) || context.location.protocol return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response &#125; function handleReadyState(r, success, error) &#123; return function () &#123; // use _aborted to mitigate against IE err c00c023f // (can't read props on aborted request objects) if (r._aborted) return error(r.request) if (r._timedOut) return error(r.request, 'Request is aborted: timeout') if (r.request &amp;&amp; r.request[readyState] == 4) &#123; r.request.onreadystatechange = noop if (succeed(r)) &#123; success(r.request) // @jch 这里调用success的方法的时候将xhr对象给传过去了，当然包括了xhr.status http code的状态码 &#125; else error(r.request) // @jch error的时候也返回了xhr.status &#125; &#125; &#125; function setHeaders(http, o) &#123; var headers = o['headers'] || &#123;&#125; , h headers['Accept'] = headers['Accept'] || defaultHeaders['accept'][o['type']] || defaultHeaders['accept']['*'] var isAFormData = typeof FormData !== 'undefined' &amp;&amp; (o['data'] instanceof FormData); // breaks cross-origin requests with legacy browsers if (!o['crossOrigin'] &amp;&amp; !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith'] if (!headers[contentType] &amp;&amp; !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType'] for (h in headers) headers.hasOwnProperty(h) &amp;&amp; 'setRequestHeader' in http &amp;&amp; http.setRequestHeader(h, headers[h]) &#125; function setCredentials(http, o) &#123; if (typeof o['withCredentials'] !== 'undefined' &amp;&amp; typeof http.withCredentials !== 'undefined') &#123; http.withCredentials = !!o['withCredentials'] &#125; &#125; function generalCallback(data) &#123; lastValue = data &#125; function urlappend (url, s) &#123; return url + (/\\?/.test(url) ? '&amp;' : '?') + s &#125; function handleJsonp(o, fn, err, url) &#123; var reqId = uniqid++ , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId) , cbreg = new RegExp('((^|\\\\?|&amp;)' + cbkey + ')=([^&amp;]+)') , match = url.match(cbreg) , script = doc.createElement('script') , loaded = 0 , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1 if (match) &#123; if (match[3] === '?') &#123; url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name &#125; else &#123; cbval = match[3] // provided callback func name &#125; &#125; else &#123; url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em &#125; context[cbval] = generalCallback script.type = 'text/javascript' script.src = url script.async = true if (typeof script.onreadystatechange !== 'undefined' &amp;&amp; !isIE10) &#123; // need this for IE due to out-of-order onreadystatechange(), binding script // execution to an event listener gives us control over when the script // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html script.htmlFor = script.id = '_reqwest_' + reqId &#125; script.onload = script.onreadystatechange = function () &#123; if ((script[readyState] &amp;&amp; script[readyState] !== 'complete' &amp;&amp; script[readyState] !== 'loaded') || loaded) &#123; return false &#125; script.onload = script.onreadystatechange = null script.onclick &amp;&amp; script.onclick() // Call the user callback with the last value stored and clean up values and scripts. fn(lastValue) lastValue = undefined head.removeChild(script) loaded = 1 &#125; // Add the script to the DOM head head.appendChild(script) // Enable JSONP timeout return &#123; abort: function () &#123; script.onload = script.onreadystatechange = null err(&#123;&#125;, 'Request is aborted: timeout', &#123;&#125;) lastValue = undefined head.removeChild(script) loaded = 1 &#125; &#125; &#125; function getRequest(fn, err) &#123; var o = this.o , method = (o['method'] || 'GET').toUpperCase() , url = typeof o === 'string' ? o : o['url'] // convert non-string objects to query-string form unless o['processData'] is false , data = (o['processData'] !== false &amp;&amp; o['data'] &amp;&amp; typeof o['data'] !== 'string') ? reqwest.toQueryString(o['data']) : (o['data'] || null) , http , sendWait = false // if we're working on a GET request and we have data then we should append // query string to end of URL and not post data if ((o['type'] == 'jsonp' || method == 'GET') &amp;&amp; data) &#123; url = urlappend(url, data) data = null &#125; if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url) // get the xhr from the factory if passed // if the factory returns null, fall-back to ours http = (o.xhr &amp;&amp; o.xhr(o)) || xhr(o) http.open(method, url, o['async'] === false ? false : true) setHeaders(http, o) setCredentials(http, o) if (context[xDomainRequest] &amp;&amp; http instanceof context[xDomainRequest]) &#123; http.onload = fn http.onerror = err // NOTE: see // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e http.onprogress = function() &#123;&#125; sendWait = true &#125; else &#123; http.onreadystatechange = handleReadyState(this, fn, err) &#125; o['before'] &amp;&amp; o['before'](http) if (sendWait) &#123; setTimeout(function () &#123; http.send(data) &#125;, 200) &#125; else &#123; http.send(data) &#125; return http &#125; function Reqwest(o, fn) &#123; this.o = o this.fn = fn init.apply(this, arguments) &#125; function setType(header) &#123; // json, javascript, text/plain, text/html, xml if (header === null) return undefined; //In case of no content-type. if (header.match('json')) return 'json' if (header.match('javascript')) return 'js' if (header.match('text')) return 'html' if (header.match('xml')) return 'xml' &#125; function init(o, fn) &#123; this.url = typeof o == 'string' ? o : o['url'] this.timeout = null // whether request has been fulfilled for purpose // of tracking the Promises this._fulfilled = false // success handlers this._successHandler = function()&#123;&#125; this._fulfillmentHandlers = [] // error handlers this._errorHandlers = [] // complete (both success and fail) handlers this._completeHandlers = [] this._erred = false this._responseArgs = &#123;&#125; var self = this fn = fn || function () &#123;&#125; if (o['timeout']) &#123; this.timeout = setTimeout(function () &#123; timedOut() &#125;, o['timeout']) &#125; if (o['success']) &#123; this._successHandler = function () &#123; o['success'].apply(o, arguments) &#125; &#125; if (o['error']) &#123; this._errorHandlers.push(function () &#123; o['error'].apply(o, arguments) &#125;) &#125; if (o['complete']) &#123; this._completeHandlers.push(function () &#123; o['complete'].apply(o, arguments) &#125;) &#125; function complete (resp) &#123; o['timeout'] &amp;&amp; clearTimeout(self.timeout) self.timeout = null while (self._completeHandlers.length &gt; 0) &#123; self._completeHandlers.shift()(resp) &#125; &#125; function success (resp) &#123; var type = o['type'] || resp &amp;&amp; setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE resp = (type !== 'jsonp') ? self.request : resp // use global data filter on response text var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type) , r = filteredResponse // @jch filteredResponse 这里传入的type 为json， globalSetupOptions.dataFilter传入的时候 // 就已经是resp.responseText， 过滤掉了xhr.status. try &#123; resp.responseText = r &#125; catch (e) &#123; // can't assign this in IE&lt;=8, just ignore &#125; if (r) &#123; switch (type) &#123; case 'json': try &#123; resp = context.JSON ? context.JSON.parse(r) : eval('(' + r + ')') // @jch 这里帮处理JSON.parse的转换，所以外面我们success, error接受到的就是对象 &#125; catch (err) &#123; return error(resp, 'Could not parse JSON in response', err) &#125; break case 'js': resp = eval(r) break case 'html': resp = r break case 'xml': resp = resp.responseXML &amp;&amp; resp.responseXML.parseError // IE trololo &amp;&amp; resp.responseXML.parseError.errorCode &amp;&amp; resp.responseXML.parseError.reason ? null : resp.responseXML break &#125; &#125; self._responseArgs.resp = resp self._fulfilled = true fn(resp) self._successHandler(resp) // @jch 这里就是调用传入的success函数处理 while (self._fulfillmentHandlers.length &gt; 0) &#123; resp = self._fulfillmentHandlers.shift()(resp) &#125; complete(resp) // @jch 先进入的success处理完之后，才是调用complete函数 &#125; function timedOut() &#123; self._timedOut = true self.request.abort() &#125; function error(resp, msg, t) &#123; resp = self.request self._responseArgs.resp = resp self._responseArgs.msg = msg self._responseArgs.t = t self._erred = true while (self._errorHandlers.length &gt; 0) &#123; self._errorHandlers.shift()(resp, msg, t) // @jch // _errorHandlers的就是 调用外面出入的error函数，这里的resp就包括了xhr.status. // 但是测试 接口404的时候status并没有返回404， 而是返回的为0，难道拿不到httpCode? // 但是成功的http 200Code拿到了，在succeed 函数里就是根据r.request.status == 20\\d来判断的 // 百度搜到了这status 返回0的情况：http://blog.csdn.net/iaiti/article/details/42192659 // 我的测试情况是 跨域访问了nei的接口，但是nei里面没有这个接口，浏览器就禁止跨域访问了， // 所以还没有到返回http code的情况. // 哈哈哈，原来是这个跨域的问题，所以我不使用nei了，而是使用了http-proxy-middleware这个插件给我代理发送到nei mock数据那里， // 它这个代理相对于你本地起了一个后端服务，这个后端服务帮你转发了请求，所以不是跨域问题，所以这样成功的拿到了404的code. // 所以这里reqwest在http code不是20\\d的情况下，传给error的时候是返回了xhr.status, httpCode的，外层也是可以拿到的 &#125; complete(resp) &#125; this.request = getRequest.call(this, success, error) &#125; Reqwest.prototype = &#123; abort: function () &#123; this._aborted = true this.request.abort() &#125; , retry: function () &#123; init.call(this, this.o, this.fn) &#125; /** * Small deviation from the Promises A CommonJs specification * http://wiki.commonjs.org/wiki/Promises/A */ /** * `then` will execute upon successful requests */ , then: function (success, fail) &#123; success = success || function () &#123;&#125; fail = fail || function () &#123;&#125; if (this._fulfilled) &#123; this._responseArgs.resp = success(this._responseArgs.resp) &#125; else if (this._erred) &#123; fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t) &#125; else &#123; this._fulfillmentHandlers.push(success) this._errorHandlers.push(fail) &#125; return this &#125; /** * `always` will execute whether the request succeeds or fails */ , always: function (fn) &#123; if (this._fulfilled || this._erred) &#123; fn(this._responseArgs.resp) &#125; else &#123; this._completeHandlers.push(fn) &#125; return this &#125; /** * `fail` will execute when the request fails */ , fail: function (fn) &#123; if (this._erred) &#123; fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t) &#125; else &#123; this._errorHandlers.push(fn) &#125; return this &#125; , 'catch': function (fn) &#123; return this.fail(fn) &#125; &#125; function reqwest(o, fn) &#123; return new Reqwest(o, fn) &#125; // normalize newline variants according to spec -&gt; CRLF function normalize(s) &#123; return s ? s.replace(/\\r?\\n/g, '\\r\\n') : '' &#125; function serial(el, cb) &#123; var n = el.name , t = el.tagName.toLowerCase() , optCb = function (o) &#123; // IE gives value=\"\" even where there is no value attribute // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273 if (o &amp;&amp; !o['disabled']) cb(n, normalize(o['attributes']['value'] &amp;&amp; o['attributes']['value']['specified'] ? o['value'] : o['text'])) &#125; , ch, ra, val, i // don't serialize elements that are disabled or without a name if (el.disabled || !n) return switch (t) &#123; case 'input': if (!/reset|button|image|file/i.test(el.type)) &#123; ch = /checkbox/i.test(el.type) ra = /radio/i.test(el.type) val = el.value // WebKit gives us \"\" instead of \"on\" if a checkbox has no value, so correct it here ;(!(ch || ra) || el.checked) &amp;&amp; cb(n, normalize(ch &amp;&amp; val === '' ? 'on' : val)) &#125; break case 'textarea': cb(n, normalize(el.value)) break case 'select': if (el.type.toLowerCase() === 'select-one') &#123; optCb(el.selectedIndex &gt;= 0 ? el.options[el.selectedIndex] : null) &#125; else &#123; for (i = 0; el.length &amp;&amp; i &lt; el.length; i++) &#123; el.options[i].selected &amp;&amp; optCb(el.options[i]) &#125; &#125; break &#125; &#125; // collect up all form elements found from the passed argument elements all // the way down to child elements; pass a '&lt;form&gt;' or form fields. // called with 'this'=callback to use for serial() on each element function eachFormElement() &#123; var cb = this , e, i , serializeSubtags = function (e, tags) &#123; var i, j, fa for (i = 0; i &lt; tags.length; i++) &#123; fa = e[byTag](tags[i]) for (j = 0; j &lt; fa.length; j++) serial(fa[j], cb) &#125; &#125; for (i = 0; i &lt; arguments.length; i++) &#123; e = arguments[i] if (/input|select|textarea/i.test(e.tagName)) serial(e, cb) serializeSubtags(e, [ 'input', 'select', 'textarea' ]) &#125; &#125; // standard query string style serialization function serializeQueryString() &#123; return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments)) &#125; // &#123; 'name': 'value', ... &#125; style serialization function serializeHash() &#123; var hash = &#123;&#125; eachFormElement.apply(function (name, value) &#123; if (name in hash) &#123; hash[name] &amp;&amp; !isArray(hash[name]) &amp;&amp; (hash[name] = [hash[name]]) hash[name].push(value) &#125; else hash[name] = value &#125;, arguments) return hash &#125; // [ &#123; name: 'name', value: 'value' &#125;, ... ] style serialization reqwest.serializeArray = function () &#123; var arr = [] eachFormElement.apply(function (name, value) &#123; arr.push(&#123;name: name, value: value&#125;) &#125;, arguments) return arr &#125; reqwest.serialize = function () &#123; if (arguments.length === 0) return '' var opt, fn , args = Array.prototype.slice.call(arguments, 0) opt = args.pop() opt &amp;&amp; opt.nodeType &amp;&amp; args.push(opt) &amp;&amp; (opt = null) opt &amp;&amp; (opt = opt.type) if (opt == 'map') fn = serializeHash else if (opt == 'array') fn = reqwest.serializeArray else fn = serializeQueryString return fn.apply(null, args) &#125; reqwest.toQueryString = function (o, trad) &#123; var prefix, i , traditional = trad || false , s = [] , enc = encodeURIComponent , add = function (key, value) &#123; // If value is a function, invoke it and return its value value = ('function' === typeof value) ? value() : (value == null ? '' : value) s[s.length] = enc(key) + '=' + enc(value) &#125; // If an array was passed in, assume that it is an array of form elements. if (isArray(o)) &#123; for (i = 0; o &amp;&amp; i &lt; o.length; i++) add(o[i]['name'], o[i]['value']) &#125; else &#123; // If traditional, encode the \"old\" way (the way 1.3.2 or older // did it), otherwise encode params recursively. for (prefix in o) &#123; if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add) &#125; &#125; // spaces should be + according to spec return s.join('&amp;').replace(/%20/g, '+') &#125; function buildParams(prefix, obj, traditional, add) &#123; var name, i, v , rbracket = /\\[\\]$/ if (isArray(obj)) &#123; // Serialize array item. for (i = 0; obj &amp;&amp; i &lt; obj.length; i++) &#123; v = obj[i] if (traditional || rbracket.test(prefix)) &#123; // Treat each array item as a scalar. add(prefix, v) &#125; else &#123; buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add) &#125; &#125; &#125; else if (obj &amp;&amp; obj.toString() === '[object Object]') &#123; // Serialize object item. for (name in obj) &#123; buildParams(prefix + '[' + name + ']', obj[name], traditional, add) &#125; &#125; else &#123; // Serialize scalar item. add(prefix, obj) &#125; &#125; reqwest.getcallbackPrefix = function () &#123; return callbackPrefix &#125; // jQuery and Zepto compatibility, differences can be remapped here so you can call // .ajax.compat(options, callback) reqwest.compat = function (o, fn) &#123; if (o) &#123; o['type'] &amp;&amp; (o['method'] = o['type']) &amp;&amp; delete o['type'] o['dataType'] &amp;&amp; (o['type'] = o['dataType']) o['jsonpCallback'] &amp;&amp; (o['jsonpCallbackName'] = o['jsonpCallback']) &amp;&amp; delete o['jsonpCallback'] o['jsonp'] &amp;&amp; (o['jsonpCallback'] = o['jsonp']) &#125; return new Reqwest(o, fn) &#125; reqwest.ajaxSetup = function (options) &#123; options = options || &#123;&#125; for (var k in options) &#123; globalSetupOptions[k] = options[k] &#125; &#125; return reqwest&#125;);","tags":[]},{"title":"JS的跨域理解","date":"2017-01-02T11:16:57.000Z","path":"2017/01/02/cors/","text":"前言博客搬家周一的学院点开题被批的很惨，换了个校长，各种被抓严，班上已经有两个同学打算休学了。哎，这周的聚会可能是大家集聚的最后一次吧。熬着吧，还是学习我的前端，不管老板学校咋逼了，找个好工作才是王道。今天把学习的几种跨域方法做个小结吧，不然就很容易忘了。 什么是跨域？JavaScript处于安全方面的考虑，不允许跨域调用其他页面的对象。也就是说a.com域名下的JS无法操作b.com或者c.a.com域名下的对象。JS跨域就是要解决在不同的域之间的数据传输或通信。只要是协议、域名、端口有任何一个的不同，都被当做是不同的域。 JSONP跨域JsonP跨域是我们最常见的跨域方法，它所基于的原理：直接通过XMLHttpRequest是不能请求不同域的数据，但是我们可以在页面中引入不同域的JS文件。 假设a.html页面里面要获取 http://b.com/data.php里面的json数据。那么我们可以在a.html页面中可以这样实现：123456&lt;script&gt; function cb(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src=\"http://b.com/data.php?callback=cb\"&gt;&lt;/script&gt; 在创建的script标签里src的url后面有个?callback=cb,这里cb就是我们获取数据后要执行的函数。 在data.php里面，返回的必须是一段可执行的JS文件。如下： 12345&lt;?php $callback = $_GET['callback']; //得到回调函数名cb $data = array('a','b','c'); //返回的数据 echo $callback.'('.json_encode($data).')';?&gt; 最终a.html页面得到的结果是cb([‘a’,’b’,’c’])。这就得到我们想要的数据了。在这里我们在页面源头引入了一段JSONP用来跨域的脚本，这样如果在一个页面里面需要跨域去获取很多数据的时候，那么就会需要引入很多跨域的脚本，一个优化的方式是可以在跨域回调函数里面获取到数据处理完之后之后，将这段异步脚本给删除掉。 JSONP跨域的优缺点 优点: 兼容性很好，而且不需要XMLHttpRequest对象也可以完成跨域获取数据了。 缺点：JSONP只支持GET操作，这样就会限制传输的数据大小了；也不能传输文件类型的数据；需要和服务器端的约定和配合，服务器端将需要返回的数据和callback回调组装一起返回给客户端。 iframe跨域网易的登录组件内嵌到各个产品中去就是通过iframe跨域通信的方式。它的原理是利用iframe的src属性，跨域拿去所需资源，该资源可以是存放在目标服务器的一个代理文件，该代理文件与目标服务器在同一个域名下，资源的通信就不是跨域了。通过这样将消息传递方式从跨域转变为两个窗体之间的通信。该代理文件则负责消息的接受和转发工作。 首先知道一个知识点：如果父页面引入一个同域的子页面，那么这两个窗体的通信就是很容易的，父页面可以通过调用子页面的window.frames[‘name’].contentWindow进行操作子页的DOM树等，且子页面也同样可以调用父页面的window.parent.contentWindow来操作父页面的DOM树。但是如果两个窗体的跨域的情况下，则会有限制，父窗体几乎拿不到子窗体的信息，window.frames[‘name’].location.href及window.frames[‘name’].contentWindow都是会报错的，同样子窗体可以重写父窗体的href属性，例如：window.parent.location.href = “http://www.baidu.com&quot;;但是却对父窗体的href属性没有读的权限。那两个窗体之间是如何通信的尼。在高版本浏览器中我们可以通过postMessage在两个窗体之间通信，低版本通过window.name的方式通信。 postMessage消息通信方式1.父子窗体之间的简单通信：parent.html里面，域名为:http://localhost:9001sub.html里面，域名为：http://localhost:9002 12345678910111213&lt;p&gt;父页面&lt;/p&gt; &lt;iframe src=\"http://localhost:9002/sub.html\" name=\"nejFrame\"&gt;&lt;/iframe&gt;&lt;p style=\"color:green\" id=\"ad\"&gt;&lt;/p&gt;&lt;script type=\"text/javascript\"&gt; function receiveMessage(msg) &#123; // 源 msg.origin document.getElementById('ad').innerHTML = msg.data; &#125; window.frames.onload = function () &#123; window.frames['nejFrame'].postMessage(\"我是来自父窗体的消息\", 'http://localhost:9002'); &#125; window.addEventListener(\"message\", receiveMessage, false);&lt;/script&gt; 注意父页面内发送消息的时候需要在iframe加载完之后。123456789&lt;p&gt;子页面&lt;/p&gt;&lt;p style=\"color:red\" id=\"eg\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function receiveMessage(msg) &#123; document.getElementById('eg').innerHTML = msg.data; &#125; window.parent.postMessage(\"我是来自子窗体的消息\", 'http://localhost:9001'); window.addEventListener(\"message\", receiveMessage, false);&lt;/script&gt; 2.兄弟之间的窗体通信可通过由父窗体进行转发，也可通过MessageChannel建立起一个通道进行通信，大家可以自行研究一下。 对于低版本的ie678，采用window.name来进行消息通信，主要利用了跨域窗体之间是可以设置window.name的特性。window.name通信过程如下：1.parent窗体按照协议拼接好消息。2.parent窗体将消息字符串设置到sub窗体的window.name属性上。3.sub窗体定时的轮询window.name的变化情况。4.sub发现window.name上有parent传来的消息，按照协议进行消息的转码。5.sub触发window上的onmessage事件，通知上层应用处理消息。上述所讲到的协议主要是字符串的设置格式： 必须以字符串 MSG| 作为起始，且必须大写字符 参数以键值对方式传入，键与值之间用 = 连接，所有键值均做encodeURIComponent编码，键值对之间以 | 字符分隔，如 a=b|b=a%26b 将以上结果做escape后设置到目标window的name属性上，如MSG%7Cdata%3D%257B%2522url%2522%253A%2522http%253A%252F%252Fa.b.com iframe跨域的优缺点 优点：兼容性比较好，低版本浏览器也可以支持，而且支持GET、POST等方式。 缺点：首次需要从目标服务器加载一个代理文件，低版本的浏览器是通过window.name的轮询机制，存在一定的消息丢失，并且在消息并发量大的时候存在一定的延时。CORS跨域CORS是w3c新出的一个跨域方案，对于该方案，前端几乎不需要做额外的操作，仅需要在服务器端在请求头中加上跨域请求头的配置，如下：Access-Control-Allow-Origin: 允许跨域访问的源，可为*.Access-Control-Expose-Headers: X-Request-With,Content-TypeAccess-Control-Allow-Methods: GET,POST,PUT,OPTIONAccess-Control-Allow-Credentials: true, 允许客户端带withCredentials为true的请求，客户端带cookie的情况Access-Control-Max-Age: 指明预检请求的响应的有效时间. 在跨域请求的时候，如果是非简单请求，如POST请求application/json类型的时候，浏览器会发送一个OPTION请求，服务器端将可以跨域请求的头信息返回给客户端，客户端收到了reponse的跨域请求头之后，再发送之后的请求。在需求跨域带cookie的情况下Access-Control-Allow-Credentials: true设置为true之后，则Access-Control-Allow-Origin不能设置为*，必须设置为具体的源。CORS方案仅支持高版本浏览器，ie67不支持，ie8下支持度不是很好，并且不能带上cookie，和contentType. CORS跨域的优缺点 优点：仅需要服务器端配置头即可，并且可以配置在ngnix上，前后端都不需要额外的操作。 缺点：仅支持高版本的浏览器 Ngnix的代理通过Ngnix进行请求代理的转发，在服务器端就不存在跨域了，通过配置proxy_pass转发。网易163邮箱和126邮箱的登录就是通过该方法。 Flash跨域Flash的跨域和iframe的跨域方式差不多，都是通过代理文件实现的，目前flash方式用的比较少了。 总结1.在少量的跨域请求时可以用JSONP的方式。2.能利用Ngnix代理则利用Ngnix代理配置进行转发，目前很多前后端分离的项目，前端单独服务器部署，本身就用到了Ngnix的代理转发到后端。3.在移动端和仅需要支持版本浏览器的时候使用CORS跨域方案。4.需要支持IE8以下的低版本浏览器的时候使用iframe方式。","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]}]