[{"title":"30岁的阶段","date":"2021-07-23T06:29:00.000Z","path":"2021/07/23/30岁的阶段/","text":"时间过的太快，转眼已经有娃，30岁最好的礼物：一一。","tags":[]},{"title":"多 tab 页 sessionStorage 不共享问题","date":"2021-07-21T07:17:45.000Z","path":"2021/07/21/sessionStorage/","text":"sessionStorage 介绍说起 sessionStorage, 大家肯定都不陌生，浏览器的 sessionStorage 属性允许我们存储一些 key/value 的数据。与 localStorage 的不同之处，sessionStorage 里存储的数据在每次关闭浏览器之后就没有了，是会话级别的数据存储。而 localStorage 存储的数据是永久性的，在关闭浏览器之后也不会消失，下次再打开浏览器时，数据依然存在，除非你手动的进行删除。 sessionStorage 的 api 也是非常的简单。1234// 存储数据sessionStorage.setItem('name', 'jch');// 获取数据sessionStorage.getItem('name'); // 'jch' 问题描述看似很简单实用的一个属性，却也在打开多个 tab 页面时引起了问题。 问题出现场景： 在一个后端任务管理系统中，菜单里有很多任务相关的页面，这些任务都与服务器有关。很多类似这样的系统下系统顶部 topmenu 都有一个 切换服务器的功能，每次点击切换服务器之后，当前页面的数据都需要刷新，即重新的请求后端数据，并且希望页面刷新。后端这个时候希望这个 服务器 的信息是前端写在 cookie 中，这里暂不说其他方式。 这是需求的一个描述，简化一下就是：点击切换服务器 topmenu 的时候，写 cookie，并且刷新浏览器. 在不关闭浏览器的情况下刷新浏览器都是刚刚选择的服务器。既然需要刷新浏览器记住数据，自然而然我想到了写 sessionStorage. 做法是： 点击切换服务器时，写 sessionStorage 记住当前选择的服务器并重新刷新浏览器，在进入系统 App 根路由时读取 sessionStorage 判断是否有记录服务器的值，若没有的话 topmenu 默认选择列表的第一个并写 cookie，这样后面请求都会带上这个 cookie 了。若有的话，根据该 sessionStorage 写 cookie 并且 topmenu 的 selected 值就是 sessionStorage 里的值。这样看起来没有啥问题，妥妥的完成了需求。然而 bug 无所不在，当你在一个 tab 页面里面切换了服务器之后，系统里面一个 a 标签新开一个 tab 页面查看某个任务详情的时候，新开的 tab 页面里面默认最开始是选择第一个服务器，因为两个 tab 页面的 sessionStorage 是不共享的。这样在打开的新 tab 页面的时候，默认选择了第一个服务器，并且写下了 cookie 值为第一个服务器，这样奇怪的问题就会出现了，再次回到第一个 tab 的时候，点击其他页面请求的数据都是第二个 tab 选择的服务器值，而第一个 tab 的 topmenu 显示的还是刚刚选择过的服务器，这样就不对了。产生这个问题的原因是不同页面的 sessionStorage 是不共享的，而 cookie 是共享的，cookie 是针对域名下的。我们在打开新 tab 的时候，因为该 tab 下 sessionStorage 没有记录服务器的值，我们默认选择了第一个服务器，并且写了 cookie, 这样就导致 cookie 值被更新了，回到第一个页面的时候再次请求 cookie 就是不对了。 看到这个问题之后，才了解到 sessionStorage 和 localStorage 其实还有一个更大的不同点，在不同 tab 下 sessionStorage 是不共享的，而 localStorage 是共享的。既然 localStorage 是共享的，那么就可以解决上面我们新开页面因 sessionStorage 不共享导致写 cookie 错乱的问题了。 解决问题知道问题的源头在哪里，解决起来就很简单了，只要把上面记录服务器的信息写在 localStorage 中就可以了，这样新开 tab 页的时候，在根路由 App 里面判断 localStorage 的时候就已经有值了，并且和第一个 tab 是一样的，这样写的 cookie 也是一样的。解决了这个之后，还有一个问题是 开了两个 tab 情况时，在不同的 tab 里面切换服务器的时候，也会导致一个 cookie 错乱的问题。其实后端想放在 cookie 里面记录这个服务器的值，就是希望这个服务器的信息和用户登录一样的，不管开多少个页面，大家都是保持一样的一个情况。这样就需要多 tab 页里面更改 localStorage 的时候需要互相通知到。嗯，强大的浏览器已经有这样的 API 供我们使用了，我们可以在 App 根路由处监听 storage 的变化，如下：123456window.addEventListener('storage', event =&gt; &#123; // servername 为 localStorage 的 key if (event.key === 'servername') &#123; this.data.serverName = event.newValue; // newValue 即为新设置的 localStorage 的值，更新 topmenu 为 localStorage 里的值，保持多 tab 页一致。 &#125;&#125;); 这样问题就彻底解决了。通过 localStorage 及监听 storage 事件，我们也可以用一个 localStorage 实现多 tab 页共享 sessionStorage, 通过上面分析，想来大家都知道怎么做了，那就动手去实现下吧！","tags":[{"name":"sessionStorage","slug":"sessionStorage","permalink":"http://yoursite.com/tags/sessionStorage/"}]},{"title":"记一次 react 事件踩坑","date":"2019-03-17T12:36:23.000Z","path":"2019/03/17/react event/","text":"最初刚开始用 react 开发，对于其某些 API 还是有些不熟悉，在使用其事件机制时就踩坑了，所以阅读了其事件机制，才真正知道了坑踩在哪里了，首先来看下一次事件踩坑。 踩坑首先一个需求是用 svg 画一个元素，该元素整体可拖拽(目标元素位置不动，只拖动出一个副本)，点击其中某个小圆点时不触发拖拽，点击小圆点要随着鼠标画线。踩坑的 demo, demo 中是简化了的版本，没有画 svg, 用一个 div 代替了，点击圆点画线也省略了。 主体思路是提供一个 Draggable 组件，通过组合的方式提供拖拽功能，Draggable 拖拽功能是通过 mouse 事件实现的，因为 svg 元素不支持 h5 的 drag 事件。可以看下主要的结构： 1234567891011121314// Draggable.jsxcomponentDidMount() &#123; // eslint-disable-next-line react/no-find-dom-node this.$el = ReactDOM.findDOMNode(this); // 方式一： addEventListener this.$el.addEventListener(\"mousedown\", this.onMousedown);&#125;render() &#123; const &#123; children &#125; = this.props; const child = React.Children.only(children); // 方式一 + componentDidMount 里的 addEventListneer return &lt;React.Fragment&gt;&#123;child&#125;&lt;/React.Fragment&gt;;&#125; 最开始的实现方式，Draggable.jsx 通过 findDOMNode 找到 children 的根元素，直接通过 addEventListener 注册 mousedown 事件，开始记录拖动的元素。 123456789101112// index.jsfuntion onMouseDown(event) &#123; event.stopPropagation();&#125;render() &#123; &lt;Draggable&gt; &lt;div className=\"node\"&gt; &lt;span&gt;可拖拽&lt;/span&gt; &lt;div className=\"dot\" onMouseDown=&#123;onMouseDown&#125; /&gt; &lt;/div&gt; &lt;/Draggable&gt;&#125; 在 index.js 里引入 Draggable 包裹需要拖拽的元素，点击小圆点的时候想要不触发拖拽，自然想到是通过 stopPropagation 阻止 mousedown 事件的冒泡，这样就不会触发拖拽的操作了。可是坑来了，怎么阻止不了冒泡啊？console.log 打印出来看一下，是先触发了 Draggable 里的 onMouseDown 事件，然后才调用了 index.js 里的 onMouseDown 事件，顿时觉得啥？这和我知道的事件冒泡机制完全不一样啊，react 打底做了啥？其实网上搜一个就能出来解决方案的，Draggable 组件无非是想给 children 绑定一个 onMouseDown 事件嘛，其实熟悉了 react 之后，立马就能解决这个问题了。我们后面再说，好奇的宝宝先让我们来了解下 react 的事件机制。 React 事件机制React 自己实现了一套高效的事件注册，存储和分发系统，进行了性能优化，减少了内存的消耗。解决了浏览器之间的事件兼容性问题。下图是官网提供的一个事件流程图：12345678910111213141516171819202122232425262728293031* Overview of React and the event system:** +------------+ .* | DOM | .* +------------+ .* | .* v .* +------------+ .* | ReactEvent | .* | Listener | .* +------------+ . +-----------+* | . +--------+|SimpleEvent|* | . | |Plugin |* +-----|------+ . v +-----------+* | | | . +--------------+ +------------+* | +-----------.---&gt;|EventPluginHub| | Event |* | | . | | +-----------+ | Propagators|* | ReactEvent | . | | |TapEvent | |------------|* | Emitter | . | |&lt;---+|Plugin | |other plugin|* | | . | | +-----------+ | utilities |* | +-----------.---&gt;| | +------------+* | | | . +--------------+* +-----|------+ . ^ +-----------+* | . | |Enter/Leave|* + . +-------+|Plugin |* +-------------+ . +-----------+* | application | .* |-------------| .* | | .* | | .* +-------------+ . 下面主要从事件注册和事件执行的主要源码来讲解。源码只展示了主要的逻辑功能代码，加上注解的形式分析。 事件注册1234567891011121314151617181920212223// ReactDOMComponent.js_updateDOMProperties: function (lastProps, nextProps, transaction) &#123; ... for (propKey in nextProps) &#123; // 判断是否为事件属性，registrationNameModules &#123; onBlur, onClick ..... &#125; if (registrationNameModules.hasOwnProperty(propKey)) &#123; enqueuePutListener(this, propKey, nextProp, transaction); &#125; &#125; &#125;&#125;function enqueuePutListener(inst, registrationName, listener, transaction) &#123; ... var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument; // listenTo 将事件注册到 document 上 listenTo(registrationName, doc); // putListener 存储事件，放入事务队列中 transaction.getReactMountReady().enqueue(putListener, &#123; inst: inst, registrationName: registrationName, listener: listener &#125;);&#125; 解析组件 props 事件，通过 listenTo 将事件注册到 document 上，listenTo 里面会判断是事件的冒泡还是捕获。本文下面我们都主要看事件的冒泡处理部分。 1234567891011121314151617181920212223242526272829303132// ReactBrowserEventEmitter.jslistenTo: function (registrationName, contentDocumentHandle) &#123; ... if (...) &#123; // 事件冒泡 ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(...); &#125; else if (...) &#123; // 事件捕获 ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(...); &#125; ...&#125;// ReactEventListener.jsvar ReactEventListener = &#123; ... trapBubbledEvent: function (topLevelType, handlerBaseName, element) &#123; ... var handler = ReactEventListener.dispatchEvent.bind(null, topLevelType); // EventListener.listen 进行事件注册。handler 仅仅调用了一个 dispatchEvent 分发事件。 return EventListener.listen(element, handlerBaseName, handler); &#125;, trapCapturedEvent: function (topLevelType, handlerBaseName, element) &#123; var handler = ReactEventListener.dispatchEvent.bind(null, topLevelType); return EventListener.capture(element, handlerBaseName, handler); &#125; dispatchEvent: function (topLevelType, nativeEvent) &#123; ... ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); ... &#125;&#125; listenTo 最后会调用 listen 函数，在 listen 函数里面我们看到了熟悉的绑定事件的代码，react 帮我们处理了各个浏览器之间的兼容性问题。 123456789101112131415161718// 熟悉的事件绑定listen: function listen(target, eventType, callback) &#123; if (target.addEventListener) &#123; target.addEventListener(eventType, callback, false); return &#123; remove: function remove() &#123; target.removeEventListener(eventType, callback, false); &#125; &#125;; &#125; else if (target.attachEvent) &#123; target.attachEvent('on' + eventType, callback); return &#123; remove: function remove() &#123; target.detachEvent('on' + eventType, callback); &#125; &#125;; &#125;&#125; 上面对 props 事件的处理，主要调用了 listenTo 将事件绑定到了 document 上，所有的事件存储调用了 EventPluginHub 的 putListener。 123456789101112131415161718// EventPluginHub.jsvar listenerBank = &#123;&#125;;var getDictionaryKey = function (inst) &#123; return '.' + inst._rootNodeID;&#125;var EventPluginHub = &#123; putListener: function (inst, registrationName, listener) &#123; ... var key = getDictionaryKey(inst); // 将 listener 事件回调方法存入 listenerBank[registrationName][key] 中, // 比如 listenerBank['onclick'][nodeId] // 所有 React 组件对象定义的所有 React 事件都会存储在 listenerBank 中 var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = &#123;&#125;); bankForRegistrationName[key] = listener; ... &#125;&#125; putListener 将事件存储在 listenerBank 对象中，在后面的合成事件里面会获取该对象里面的回调函数。 事件执行在上述事件的绑定过程中，可以看到所有事件的执行都是调用了 dispatchEvent 方法，该方法主要将事件分发的真正核心—— handleTopLevelImpl 方法放入批处理队列中。 1234567891011121314151617// ReactEventListener.jsfunction handleTopLevelImpl(bookKeeping) &#123; var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent); var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget); var ancestor = targetInst; do &#123; bookKeeping.ancestors.push(ancestor); ancestor = ancestor &amp;&amp; findParent(ancestor); &#125; while (ancestor); // 从当前组件向父组件遍历,依次执行注册的回调方法. 我们遍历构造ancestors数组时,是从当前组件向父组件回溯 // 的, 模拟了事件的冒泡顺序。 for (var i = 0; i &lt; bookKeeping.ancestors.length; i++) &#123; targetInst = bookKeeping.ancestors[i]; ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent)); &#125;&#125; 可以看到这里 react 通过队列的方式模拟的事件的冒泡。 _handleTopLevel 方法处理了真正的回调。 123456_handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) &#123; // 获取合成事件, 合成事件过程会从上述注册阶段中的 EventPluginHub listenerBank 中获取相关回调函数 var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget); // 批处理事件 runEventQueueInBatch(events);&#125; EventPluginHub.extractEvents 调用了事件 Plugins 进行合成事件。合成事件处理了事件跨浏览器的兼容性(如 transitionEnd, webkitTransitionEnd, MozTransitionEnd 和 oTransitionEnd)等，并且采用了一个事件池的一个概念，避免了频繁的创建对象分配内存及垃圾回收操作，达到一个性能优化。 我们可以直观感受下 react 的事件池概念，在事件回调中，如果我们要异步的去拿取 event 事件时，就会发现该对象的 nativeEvent 是 null 的，如下面 setTimeout 里面。这就是 react 事件池的一个优化机制，在事件对象被用完之后，会重新的放回池中，供下次使用。如果想要异步的返回事件对象的话，需要调用 event.persist(); 让事件不进行释放。 123456onMouseDown(event) &#123; // event.persist(); setTimeout(() =&gt; &#123; console.log(event); &#125;, 100)&#125; 此处就不再介绍合成事件的过程，感兴趣的同学可以参考这边文章：React细节知识之对象池 批处理 runEventQueueInBatch 的核心函数 executeDispatchesInOrder，执行 React 组件中 JSX 申明的回调函数。123456789101112131415161718192021222324252627282930313233343536373839404142// EventPluginUtils.jsfunction executeDispatchesInOrder(event, simulated) &#123; // dispatchListeners 为事件队列 var dispatchListeners = event._dispatchListeners; var dispatchInstances = event._dispatchInstances; if (Array.isArray(dispatchListeners)) &#123; for (var i = 0; i &lt; dispatchListeners.length; i++) &#123; if (event.isPropagationStopped()) &#123; break; &#125; // dispatchListeners[i] 为 JSX 中声明的事件 callback // dispatchInstances[i] 为对应的 React Component executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]); &#125; &#125; else if (dispatchListeners) &#123; executeDispatch(event, simulated, dispatchListeners, dispatchInstances); &#125; event._dispatchListeners = null; event._dispatchInstances = null;&#125;function executeDispatch(event, simulated, listener, inst) &#123; var type = event.type || 'unknown-event'; event.currentTarget = EventPluginUtils.getNodeFromInstance(inst); if (simulated) &#123; ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event); &#125; else &#123; ReactErrorUtils.invokeGuardedCallback(type, listener, event); &#125; event.currentTarget = null;&#125;function invokeGuardedCallback(name, func, a) &#123; try &#123; // 回调函数是直接调用的，并没有指定调用的组件，所以在组件里面需要手动绑定this. func(a); &#125; catch (x) &#123; if (caughtError === null) &#123; caughtError = x; &#125; &#125;&#125; 在 invokeGuardedCallback 方法里面我们也看到了为什么我们在写 react 方法时需要手动的绑定 this. 总结上面就介绍完成了 react 事件机制从事件注册到事件执行的整个过程，整个事件机制还是蛮复杂的，其中还是有很多细节有待深入研究。从上述过程中可以得到 react 事件机制的几个特点： 几乎所有的事件都是绑定在 document 上，除了 video, andio 标签的 onPlay, onPause 等，这些事件是document 不具有的，那么只能在这些标签上进行事件绑定。 React 以队列的方式，自身模拟了一套事件冒泡机制，对于原生事件和合成事件混用的情况下，我们没办法通过 event.stopPropagation() 来组织原生事件的传播。因为 react 的事件都是先冒泡到 document 上之后，才会进行事件的分发处理。 React 使用对象池来管理合成事件对象的创建和销毁，这样减少了垃圾回收操作和新对象内存的分配，大大提高了性能。 解决问题回到最开始的问题，那么现在我们知道为什么阻止不了父组件的 onMouseDown 事件了，因为我们这里混用了原生事件和合成事件，没办法阻止原生事件的冒泡。那么该怎么做尼，其实 React 提供了 cloneElement API 进行克隆子组件，并传递 props. 所以改下 Draggable 里的render 方法：123456789101112131415componentDidMount() &#123; // eslint-disable-next-line react/no-find-dom-node this.$el = ReactDOM.findDOMNode(this); // 方式一： addEventListener // this.$el.addEventListener(\"mousedown\", this.onMousedown);&#125;render() &#123; const &#123; children &#125; = this.props; const child = React.Children.only(children); // 方法二：cloneElement return React.cloneElement(child, &#123; onMouseDown: this.onMousedown &#125;);&#125; 这样在子组件中就可以通过 event.stopPropagation() 阻止事件的冒泡了。这样做也有一个需要注意的: 123&lt;Draggable&gt; &lt;div&gt;可拖拽元素&lt;/div&gt;&lt;/Draggable&gt; 1234567891011// index.js&lt;Draggable&gt; &lt;TestNode&gt;&lt;/TestNode&gt;&lt;/Draggable&gt;// TestNode.jsxrender() &#123; &lt;div &#123;...this.props&#125;&gt; &lt;p&gt;Test&lt;/p&gt; &lt;/div&gt;&#125; 上述在 Draggable 包裹的是原生DOM时，可以在根节点上自动接受到 props。如果 Draggable 内子组件是一个 React Component 时，如上述的 onMouseDown 事件就需要手动在 TestNode 子组件 DOM 上接收 props.","tags":[{"name":"react events","slug":"react-events","permalink":"http://yoursite.com/tags/react-events/"}]},{"title":"常用的数据可视化框架","date":"2018-12-27T08:02:53.000Z","path":"2018/12/27/datavisual/","text":"最近负责的业务涉及一些数据可视化展示，面对可视化的数据展示方面，往往会选择一款第三方的可视化工具，本文主要收集了一些主流开源的数据可视化框架，并附上部分小demo供参考。 d3 Data-Driven Documents 官网: https://d3js.org/ API文档：https://github.com/d3/d3/blob/master/API.md 提到数据可视化，就不得不提大名鼎鼎的 D3。2011年，Mike Bostock、Vadim Ogievetsky 和 Jeff Heer 发布了 D3，目前 github 上 star 数已达到8万 + 。用其官网介绍，D3 是一个基于数据操作文档的库，D3 帮助你给数据带来活力通过使用 HTML、SVG 和 CSS，结合强大的可视化组件和数据驱动方式操作 Dom。使用 D3 可以实现很多自定义的动态数据交互，它的很大优点是： 灵活度高，可以使用它的基础 API 实现各种复杂的数据展示及结合自定义的交互操作。 数据绑定到 DOM，能直接操作 DOM。 自 D3 v4 开始即可基于 SVG，也可基于 Canvas 实现可视化，在数据量很大并且有交互更新视图的情况下，可使用基于 Canvas，如果数据量不是特别大的情况下，使用 SVG 非常方便。 社区活跃 demo 众多。 缺点是有一定的学习门槛，它并没有像 Echarts 样提供高度封装好的 API。 用 D3 实现一个简单的树形图展示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import * as d3 from 'd3';import './d3.scss';const data = &#123; name: '0', children: [ &#123; name: '0-0', children: [ &#123; name: '0-0-0' &#125;, &#123; name: '0-0-1' &#125;, &#123; name: '0-0-2' &#125; ] &#125;, &#123; name: '0-1', children: [ &#123; name: '0-1-0' &#125;, &#123; name: '0-1-1' &#125;, &#123; name: '0-1-2' &#125; ] &#125;, &#123; name: '0-2', &#125;, &#123; name: '0-3' &#125; ]&#125;;const width = 700, height = 700;const tree = d3.tree() .size([width, height]);const diagonal = d3.linkHorizontal() .x(function (d) &#123; return d.y; &#125;) .y(function (d) &#123; return d.x; &#125;);const svg = d3.select(\"#root\").append(\"svg\") .attr(\"width\", width + 800) .attr(\"height\", height) .append(\"g\") .attr(\"transform\", \"translate(40,0)\");const nodes = d3.hierarchy(data, d =&gt; d.children);const treeNodes = tree(nodes);// 创建线条svg.selectAll(\".link\") .data(treeNodes.links()) .enter() .append(\"path\") .attr(\"class\", \"link\") .attr(\"d\", diagonal);// 创建节点const node = svg.selectAll(\".node\") .data(treeNodes.descendants()) .enter() .append(\"g\") .attr(\"class\", \"node\") .attr(\"transform\", function (d) &#123; return \"translate(\" + d.y + \",\" + d.x + \")\"; &#125;);// 节点添加圆圈node.append(\"circle\") .attr(\"r\", 4.5);// 节点添加文本描述node.append(\"text\") .attr(\"dx\", 0) .attr(\"dy\", -8) .style(\"text-anchor\", 'middle') .text(function (d) &#123; return d.data.name; &#125;); 上面的代码是不是有种是曾相识的感觉，对，很像用 jquery 时操作 DOM 的用法。 百度的echarts 官网：http://echarts.baidu.com 相比 D3, echarts 的使用就可以说相对易用很多了。echarts 提供了大量的可视化类型，折线图、饼状图、地理图、热力图等等，并有大量的 demo, 社区也很活跃，文档也很全面。如果你的可视化展示需求比较简单，并且自定义交互并不复杂，那么 echarts 完全满足你的需求，并且使用起来也简单易用。缺点是扩展性并不是那么友好。 用 echarts 实现一个多折线图表： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import Echarts from 'echarts';const echart = Echarts.init(document.getElementById('root'));echart.setOption(&#123; title: &#123; text: '折线图' &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data:['邮件营销','联盟广告'] &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, xAxis: &#123; type: 'value', name: '区间', nameLocation: 'middle', nameTextStyle: &#123; fontWeight: 'bold', fontSize: 16 &#125;, nameGap: 25 &#125;, yAxis: &#123; type: 'value', name: '数量', nameLocation: 'middle', nameTextStyle: &#123; fontWeight: 'bold', fontSize: 16 &#125;, nameGap: 55 &#125;, series: [ &#123; name:'邮件营销', type:'line', data:[[20, 40], [40, 90], [70, 100], [90, 200]] &#125;, &#123; name:'联盟广告', type:'line', data:[[0, 40], [50, 70], [80, 100], [110, 300]] &#125; ]&#125;) 阿里的G2 官网：https://antv.alipay.com/zh-cn/g2/3.x/demo/index.html G2 是阿里在2016开源的一套图表库，图表资源丰富。\bG2 背后的理论基础，也就是图形语法是基于 Leland Wilkinson 写的 The Grammar of Graphics，有兴趣的同学可以看看。G2 的优点简单易用，用户一条语句即可构建出各种各样的可交互的统计图表，相比于 echarts G2 更易于用来扩展自定义的图表，且风格较 echarts 更美观些。G2 3.2.7以前是基于 Canvas 的，3.2.7之后也同时支持 SVG了，关于如何选择基于 Canvas 或者 SVG，可以查看 G2 关于这部分的介绍：选择 Canvas 还是 SVG。 G2 主要是一些统计图表，柱状图、饼图、地图、雷达图等，对于树形图，需要使用 G6，G6 底层依赖了 D3。 用 G2 使用实现一个多折线图表： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import G2 from '@antv/g2';import DataSet from '@antv/data-set';const data = [&#123; month: 'Jan', Tokyo: 7.0, London: 3.9&#125;, &#123; month: 'Feb', Tokyo: 6.9, London: 4.2&#125;, &#123; month: 'Mar', Tokyo: 9.5, London: 5.7&#125;, &#123; month: 'Apr', Tokyo: 14.5, London: 8.5&#125;, &#123; month: 'May', Tokyo: 18.4, London: 11.9&#125;, &#123; month: 'Jun', Tokyo: 21.5, London: 15.2&#125;, &#123; month: 'Jul', Tokyo: 25.2, London: 17.0&#125;, &#123; month: 'Aug', Tokyo: 26.5, London: 16.6&#125;, &#123; month: 'Sep', Tokyo: 23.3, London: 14.2&#125;, &#123; month: 'Oct', Tokyo: 18.3, London: 10.3&#125;, &#123; month: 'Nov', Tokyo: 13.9, London: 6.6&#125;, &#123; month: 'Dec', Tokyo: 9.6, London: 4.8&#125;];const ds = new DataSet();const dv = ds.createView().source(data);// fold 方式完成了行列转换，如果不想使用 DataSet 直接手工转换数据即可// 转化成 &#123;month: 'Jan', city: 'Tokyo', temperature: 3.9&#125;dv.transform(&#123; type: 'fold', fields: ['Tokyo', 'London'], // 展开字段集 key: 'city', // key字段 value: 'temperature' // value字段&#125;);const chart = new G2.Chart(&#123; container: 'root', width: 800, height: 500,&#125;);chart.source(dv, &#123; month: &#123; range: [0, 1] &#125;&#125;);chart.tooltip(&#123; crosshairs: &#123; type: 'line' &#125;&#125;);chart.axis('temperature', &#123; label: &#123; formatter: function formatter(val) &#123; return val + '°C'; &#125; &#125;&#125;);chart.line().position('month*temperature').color('city').shape('smooth');chart.point().position('month*temperature').color('city').size(4).shape('circle').style(&#123; stroke: '#fff', lineWidth: 1&#125;);chart.render(); 阿里的F2: 针对移动端的\b数据可视化库 官网：https://antv.alipay.com/zh-cn/f2/3.x/demo/index.html 和 G2 类似，F2 也是基于图形语法实现的一套图表库，不同的是，F2 专注于移动端，完美支持 H5 环境同时兼容多种环境（Node, 小程序，Weex），专业的移动端交互设计。使用上和 G2 差不多。 hightcharts 官网：https://www.highcharts.com/ hightcharts 和 echarts 类型，不过 echarts 是完全免费的，hightcharts 基于商业用途是需要授权。官网的 demo 也是非常的丰富。highcharts 由四部分组成：HighCharts、Highstock、Highmaps 和 gantt。HighCharts 支持的图表类型有曲线图、区域图、柱状图、饼状图、散点图和一些综合图表。 HighStock 可以为用户方便地建立股票或一般的时间轴图表，它提供先进的导航选项，预设的日期范围，日期选择器，滚动和平移等。Highmaps 提供一些地图类图表。gantt 提供甘特图类图表。 用 highcharts 实现一个多折线图表： 123456789101112131415161718192021222324252627282930313233343536373839import Highcharts from 'highcharts';import Exporting from 'highcharts/modules/exporting';Exporting(Highcharts);Highcharts.chart('root', &#123; chart: &#123; type: 'line' &#125;, title: &#123; text: 'Monthly Average Temperature' &#125;, subtitle: &#123; text: 'Source: WorldClimate.com' &#125;, xAxis: &#123; categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] &#125;, yAxis: &#123; title: &#123; text: 'Temperature (°C)' &#125; &#125;, plotOptions: &#123; line: &#123; dataLabels: &#123; enabled: true &#125;, enableMouseTracking: false &#125; &#125;, series: [&#123; name: 'Tokyo', data: [7.0, 6.9, 9.5, 14.5, 18.4, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6] &#125;, &#123; name: 'London', data: [3.9, 4.2, 5.7, 8.5, 11.9, 15.2, 17.0, 16.6, 14.2, 10.3, 6.6, 4.8] &#125;]&#125;); charts.js 官网：https://www.chartjs.org/ 非常轻量级，动画美观，且支持模块化，即开发者可以拆分 Chart.js 仅引入自己需要的部分进入工程。缺点是仅仅只有几种基础的图表类：折线图、柱状图、散点图、区域图。 阿里的L7:地理空间数据可视化 官网：https://antv.alipay.com/zh-cn/l7/1.x/demo/index.html L7 是基于地理空间的数据可视化，易用易扩展，支持海量数据的高性能和 3D 高质量渲染。 Leaflet 官网：http://leafletjs.com/ 本身的内核库很小，丰富的插件可以大幅拓展其功能，主要用于需要展示地理位置的项目。可同时运行桌面端和移动端。 Recharts 官网：http://recharts.org/zh-CN/ Recharts 是 React 结合 D3 的一个图表库，依赖于轻量级的 D3 子模块构建 SVG 元素。可以调整组件的属性与传递组件自定义你的图表。官网上提供了9中图表类型，也有响应的示例，对于习惯用 react 组件，这个图表库的用法和 react 组件用户基本一样。 用 recharts 实现的折线图表： 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; PureComponent &#125; from 'react';import ReactDOM from 'react-dom';import &#123; LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend&#125; from 'recharts';const data = [ &#123; name: 'Page A', uv: 4000, pv: 2400, amt: 2400 &#125;, &#123; name: 'Page B', uv: 3000, pv: 1398, amt: 2210 &#125;, &#123; name: 'Page C', uv: 2000, pv: 9800, amt: 2290 &#125;, &#123; name: 'Page D', uv: 2780, pv: 3908, amt: 2000 &#125;, &#123; name: 'Page E', uv: 1890, pv: 4800, amt: 2181 &#125;, &#123; name: 'Page F', uv: 2390, pv: 3800, amt: 2500 &#125;, &#123; name: 'Page G', uv: 3490, pv: 4300, amt: 2100 &#125;,];class SimpleLineChart extends PureComponent &#123; render() &#123; return ( &lt;LineChart width=&#123;600&#125; height=&#123;300&#125; data=&#123;data&#125; margin=&#123;&#123; top: 5, right: 30, left: 20, bottom: 5 &#125;&#125;&gt; &lt;XAxis dataKey=\"name\" /&gt; &lt;YAxis /&gt; &lt;CartesianGrid strokeDasharray=\"3 3\" /&gt; &lt;Tooltip /&gt; &lt;Legend /&gt; &lt;Line type=\"monotone\" dataKey=\"pv\" stroke=\"#8884d8\" activeDot=&#123;&#123; r: 8 &#125;&#125; /&gt; &lt;Line type=\"monotone\" dataKey=\"uv\" stroke=\"#82ca9d\" /&gt; &lt;/LineChart&gt; ); &#125;&#125;;ReactDOM.render( &lt;SimpleLineChart /&gt;, document.getElementById('root')); React-vis 官网：https://uber.github.io/react-vis/ React-vis 是 Uber 开源的一款图表库，包括线、面、柱状图、热图、散热图、等高线图、六角热图等等。使用上对 React 开发者非常友好，和 React 组件差不多。使用该库不需要事先掌握 D3 或任何其他 data-vis 库的知识，并提供了低级模块化的构建块组件，如 x/y 轴。官方 demo 也挺丰富的。 文中 demo 主要从代码层面展示各个框架的用法，具体代码及效果图可参考：https://github.com/wait-hua/datavisual 这里介绍的都是文档和demo都比较丰富的数据可视化框架，欢迎推荐其他好用的数据可视化框架。 References: https://github.com/xswei/d3js_doc https://blockbuilder.org/63anp3ca/e73145f5f74a3ef86e4ba76371a9d907 http://efe.baidu.com/blog/14-popular-data-visualization-tools/ http://www.10tiao.com/html/788/201809/2247489515/1.html","tags":[{"name":"数据可视化","slug":"数据可视化","permalink":"http://yoursite.com/tags/数据可视化/"}]},{"title":"译 - Vue3.0最新功能","date":"2018-12-02T06:00:00.000Z","path":"2018/12/02/vue3.0/","text":"最近参加了 vueconf 会议，见到了尤大大关于 vue3.0 即将发布的最新功能，这里将会议视频内容整理成文章，待明年 vue3.0 发布时可对照源码学习下。 Vue3.0主要会带来哪些功能 更快 更小 更易于维护 更好的多端渲染支持 新功能 更快 vue3.0 将会对 virtual DOM 的实现进行完全重构，重构后的初始渲染、更新速度将会提升一倍。 更多编译时的优化以减少运行时的开销。如下几个编译时优化： 在 vue2.0 中对 template 里的代码直接编译成字符串，对于组件也是用字符串表示，然后在运行的时候再去判断到底是原生的 DOM，还是我们写的组件。在 vue3.0 中，将会在编译阶段就直接判断，如果是组件，直接生成组件代码对应的原生 virtual DOM。如下所示： 123456789101112131415// Template&lt;Comp&gt;&lt;/Comp&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;// Compiler outputrender() &#123; const Comp = resolveComponent('Comp', this) return createFragment([ createComponentVNode(Comp, null, null, 0 /* no children */), createElementVNode('div', null, [ createElementVNode('span', null, null, 0 /* no children */) ], 2 /* single vnode child */) ], 8 /* multiple non-keyed children */)&#125; 并且在编译成 VNode 时，会记录一些信息跳过不需要的条件判断，如上面 div 下面只有一个子元素，在编译成 VNode 时，用2标记了只有一个子节点。并且在生成 virtual DOM 时函数调用尽可能的形状一致，如上面调用 createElementVNode 的时候函数参数个数是一样的，这样可以生成更易于被 JS 引擎优化的代码。 优化 slots 生成。如下所示： 1234// Template&lt;Comp&gt; &lt;div&gt;&#123;&#123; hello &#125;&#125;&lt;/div&gt;&lt;/Comp&gt; 在 vue2.0 中，hello 做为一个动态的 hello 传递到了子组件里，当我们要更新hello这个内容时，我们需要先更新父组件，父组件更新生成新的 slots 内容传递到子组件，然后子组件再更新。这样为了更新 hello 这个内容，同时触发了两个组件的更新。在 vue3.0 中把所有的 slot 统一成为一个函数传递到子组件中，由子组件自己来决定什么时候调用这函数，如下 vue3.0 中 slots 编译后的代码： 123456// Compiler outputrender() &#123; return h(Comp, null, &#123; default: () =&gt; [h('div', this.hello)] &#125;, 16 /* compiler generated slots */)&#125; 这样 hello 的更新只会触发子组件的更新，确保精确的组件级别依赖收集，避免不需要的父子关联更新。 静态属性的提取。在 vue2.0 中做了静态内容的提取，对于完全静态的内容，直接提取出来，在之后可以直接复用这块 virtual DOM，并且比对过程中可以直接跳过整块这个内容。但是在 vue2.0 中，只要 html 中有一部分时动态的，那么它就不能被完全的静态化。如下 div 中包含一个动态的 text。 123&lt;div id=\"foo\" class=\"bar\"&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt; 在 vue3.0 中，如果这个元素本身的属性都是静态的，如上面 div 的 id、class，vue3.0 会将它的属性对象给提取出来，之后的比较中，这个元素本身就不需要比对了，只需要比对它的 children 即可。 内联事件函数提取。如下所示： 1&lt;Comp @event=\"count++\"/&gt; 其中的 count++ 其实会生成一个内联函数，每次渲染的时候都会生成一个新的内联函数，这个函数跟之前的函数是不一样的两个函数，虽然两个函数做的事情都是一样的，但是为了安全起见，每次都会重新渲染这个子组件每次都重新渲染。在 vue3.0 中，在这个函数生成一遍之后，就将它 cache 起来，之后的每次都用这同一个函数，避免子组件的再次重新更新，如下编译后的代码所示： 123456789import &#123; getBoundMethod &#125; from 'vue'function __fn1 () &#123; this.count++&#125;render() &#123; return h(Comp, &#123; onEvent: getBoundMethod(__fn1, this) &#125;)&#125; 基于 Proxy 的新数据监听系统，全语言特性支持 + 更好的性能。vue3.0 中将放弃 Object.defineProperty，使用 Proxy 的全新数据监听，我们知道 Object.defineProperty 对于对象属性的添加，数组的 push 等操作都是监听不到的，Proxy可以监听到对象属性增添/删除，数组 index/length 更改等。利用 Proxy 可以减少组件实例初始化开销。但是 Proxy 仅支持 IE Edge。 通过上面这些优化，vue3.0 组件实例初始化可加快达一倍，并且占用内存减半。 更小在 vue2.0 中，所有的代码都在一个 vue 全局对象上，那些你代码中没有用到东西也没有办法扔掉。在 vue3.0 做了按需引入，只有你代码用到了哪些功能，才会去 import 相关的代码，再结合 Tree shaking 将那些没有用到的代码扔掉。这样 vue3.0 中最小核心运行时的代码大约只需要10kb gzipped。 更易于维护vue3.0 将使用 typescript 重写，并且使用了 monorepo 进行内部模块解耦。 更好的多端渲染支持 vue3.0 中提取出了一个核心的 @vue/runtime-core 包，可以使用这个核心包进行开发可运行在小程序中等其他环境中。以往 vue2.0 中如果要开发一个可运行在小程序其他端中的化，可能需要 fork 一份 vue 源码然后进行改写，这样的话后续 vue 的升级可能需要解决冲突，或者看 vue 的更新源码，这样就非常的不方便。 新功能 响应式数据监听 API。vue3.0 中开放出了一个 observable API，可实现一些响应式数据监听。如下所示： 1234567891011import &#123; observable, effect &#125; from 'vue'const state = observable(&#123; count: 0&#125;)effect(() =&gt; &#123; console.log(`count is: $&#123;state.count&#125;`)&#125;) // count is: 0state.count++ // count is: 1 轻松排查组件更新的触发原因。vue3.0 中提供了一个钩子函数，renderTriggered 在这个钩子函数中可以看到具体是什么触发了组件的更新。 123456789 const Comp = &#123; render(props) &#123; return h('div', props.count) &#125;, renderTriggered(event) &#123; debugger &#125; &#125;&#125; 更好的 TypeScript 支持，包括原生的 Class API 和 TSX。 123456789101112interface HelloProps &#123; text: string&#125;class Hello extends Component&lt;HelloProps&gt; &#123; count = 0 render() &#123; return &lt;div&gt; &#123;this.count&#125; &#123;this.$props.text&#125; &lt;/div&gt; &#125; &#125; 更好的警告信息。 组件堆栈包含函数式组件 可以直接在警告信息中查看组件的 props 在更多的警告中提供组件堆栈信息 Hooks API。 即 React Hooks 的提出，vue3.0 中也将提供 Hooks API 作为一种逻辑复用机制，大概率取代 mixins。 Time Slicing Support。 React17 中也提出 time slicing: https://blog.pusher.com/time-slice-suspense-api-react-17/，让框架在进行大量 JS 计算的时候，把 JS 计算切成一帧一帧的计算，不要让大量的 js 计算 block 了浏览器的主线程，浏览器在 block 时会处于一个完全没有响应的状态，用户的输入点击等都是无法被响应的，如果用户的输入导致了大量的 JS 计算，同时用户继续输入的话，会明显的一个输入卡顿性能下降的情况。要改进这个问题，可以通过每 16ms 处理完之后交还给浏览器，让用户的事件重新进来，触发更新，中间可能还可以因用户的输入导致新的更新，之前不必要的处理就不需要执行了，这样就不会造成一个卡顿的现象。 关于IE。前面提到了使用新的proxy数据监听是不支持IE11及以下的，那么在 IE11 中自动降级为旧的 getter/setter 机制，并对 IE 中不支持的用法给出警告，并且 IE11 中享受不了部分新的功能了。看来是时候放弃兼容 IE 了，感觉很好，回想兼容 IE8 是的可怕时光。。。 我不是知识的创造者，我只是知识的搬运工。","tags":[{"name":"vue3.0","slug":"vue3-0","permalink":"http://yoursite.com/tags/vue3-0/"}]},{"title":"JS的跨域理解","date":"2018-01-02T11:16:57.000Z","path":"2018/01/02/cors/","text":"什么是跨域？JavaScript处于安全方面的考虑，不允许跨域调用其他页面的对象。也就是说a.com域名下的JS无法操作b.com或者c.a.com域名下的对象。JS跨域就是要解决在不同的域之间的数据传输或通信。只要是协议、域名、端口有任何一个的不同，都被当做是不同的域。 JSONP跨域JsonP跨域是我们最常见的跨域方法，它所基于的原理：直接通过XMLHttpRequest是不能请求不同域的数据，但是我们可以在页面中引入不同域的JS文件。 假设a.html页面里面要获取 http://b.com/data.php里面的json数据。那么我们可以在a.html页面中可以这样实现：123456&lt;script&gt; function cb(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;&lt;script src=\"http://b.com/data.php?callback=cb\"&gt;&lt;/script&gt; 在创建的script标签里src的url后面有个?callback=cb,这里cb就是我们获取数据后要执行的函数。 在data.php里面，返回的必须是一段可执行的JS文件。如下： 12345&lt;?php $callback = $_GET['callback']; //得到回调函数名cb $data = array('a','b','c'); //返回的数据 echo $callback.'('.json_encode($data).')';?&gt; 最终a.html页面得到的结果是cb([‘a’,’b’,’c’])。这就得到我们想要的数据了。在这里我们在页面源头引入了一段JSONP用来跨域的脚本，这样如果在一个页面里面需要跨域去获取很多数据的时候，那么就会需要引入很多跨域的脚本，一个优化的方式是可以在跨域回调函数里面获取到数据处理完之后之后，将这段异步脚本给删除掉。 JSONP跨域的优缺点 优点: 兼容性很好，而且不需要XMLHttpRequest对象也可以完成跨域获取数据了。 缺点：JSONP只支持GET操作，这样就会限制传输的数据大小了；也不能传输文件类型的数据；需要和服务器端的约定和配合，服务器端将需要返回的数据和callback回调组装一起返回给客户端。 iframe跨域网易的登录组件内嵌到各个产品中去就是通过iframe跨域通信的方式。它的原理是利用iframe的src属性，跨域拿去所需资源，该资源可以是存放在目标服务器的一个代理文件，该代理文件与目标服务器在同一个域名下，资源的通信就不是跨域了。通过这样将消息传递方式从跨域转变为两个窗体之间的通信。该代理文件则负责消息的接受和转发工作。 首先知道一个知识点：如果父页面引入一个同域的子页面，那么这两个窗体的通信就是很容易的，父页面可以通过调用子页面的window.frames[‘name’].contentWindow进行操作子页的DOM树等，且子页面也同样可以调用父页面的window.parent.contentWindow来操作父页面的DOM树。但是如果两个窗体的跨域的情况下，则会有限制，父窗体几乎拿不到子窗体的信息，window.frames[‘name’].location.href及window.frames[‘name’].contentWindow都是会报错的，同样子窗体可以重写父窗体的href属性，例如：window.parent.location.href = “http://www.baidu.com&quot;;但是却对父窗体的href属性没有读的权限。那两个窗体之间是如何通信的尼。在高版本浏览器中我们可以通过postMessage在两个窗体之间通信，低版本通过window.name的方式通信。 postMessage消息通信方式1.父子窗体之间的简单通信：parent.html里面，域名为:http://localhost:9001sub.html里面，域名为：http://localhost:9002 12345678910111213&lt;p&gt;父页面&lt;/p&gt; &lt;iframe src=\"http://localhost:9002/sub.html\" name=\"nejFrame\"&gt;&lt;/iframe&gt;&lt;p style=\"color:green\" id=\"ad\"&gt;&lt;/p&gt;&lt;script type=\"text/javascript\"&gt; function receiveMessage(msg) &#123; // 源 msg.origin document.getElementById('ad').innerHTML = msg.data; &#125; window.frames.onload = function () &#123; window.frames['nejFrame'].postMessage(\"我是来自父窗体的消息\", 'http://localhost:9002'); &#125; window.addEventListener(\"message\", receiveMessage, false);&lt;/script&gt; 注意父页面内发送消息的时候需要在iframe加载完之后。123456789&lt;p&gt;子页面&lt;/p&gt;&lt;p style=\"color:red\" id=\"eg\"&gt;&lt;/p&gt; &lt;script type=\"text/javascript\"&gt; function receiveMessage(msg) &#123; document.getElementById('eg').innerHTML = msg.data; &#125; window.parent.postMessage(\"我是来自子窗体的消息\", 'http://localhost:9001'); window.addEventListener(\"message\", receiveMessage, false);&lt;/script&gt; 2.兄弟之间的窗体通信可通过由父窗体进行转发，也可通过MessageChannel建立起一个通道进行通信，大家可以自行研究一下。 对于低版本的ie678，采用window.name来进行消息通信，主要利用了跨域窗体之间是可以设置window.name的特性。window.name通信过程如下：1.parent窗体按照协议拼接好消息。2.parent窗体将消息字符串设置到sub窗体的window.name属性上。3.sub窗体定时的轮询window.name的变化情况。4.sub发现window.name上有parent传来的消息，按照协议进行消息的转码。5.sub触发window上的onmessage事件，通知上层应用处理消息。上述所讲到的协议主要是字符串的设置格式： 必须以字符串 MSG| 作为起始，且必须大写字符 参数以键值对方式传入，键与值之间用 = 连接，所有键值均做encodeURIComponent编码，键值对之间以 | 字符分隔，如 a=b|b=a%26b 将以上结果做escape后设置到目标window的name属性上，如MSG%7Cdata%3D%257B%2522url%2522%253A%2522http%253A%252F%252Fa.b.com iframe跨域的优缺点 优点：兼容性比较好，低版本浏览器也可以支持，而且支持GET、POST等方式。 缺点：首次需要从目标服务器加载一个代理文件，低版本的浏览器是通过window.name的轮询机制，存在一定的消息丢失，并且在消息并发量大的时候存在一定的延时。CORS跨域CORS是w3c新出的一个跨域方案，对于该方案，前端几乎不需要做额外的操作，仅需要在服务器端在请求头中加上跨域请求头的配置，如下：Access-Control-Allow-Origin: 允许跨域访问的源，可为*.Access-Control-Expose-Headers: X-Request-With,Content-TypeAccess-Control-Allow-Methods: GET,POST,PUT,OPTIONAccess-Control-Allow-Credentials: true, 允许客户端带withCredentials为true的请求，客户端带cookie的情况Access-Control-Max-Age: 指明预检请求的响应的有效时间. 在跨域请求的时候，如果是非简单请求，如POST请求application/json类型的时候，浏览器会发送一个OPTION请求，服务器端将可以跨域请求的头信息返回给客户端，客户端收到了reponse的跨域请求头之后，再发送之后的请求。在需求跨域带cookie的情况下Access-Control-Allow-Credentials: true设置为true之后，则Access-Control-Allow-Origin不能设置为*，必须设置为具体的源。CORS方案仅支持高版本浏览器，ie67不支持，ie8下支持度不是很好，并且不能带上cookie，和contentType. CORS跨域的优缺点 优点：仅需要服务器端配置头即可，并且可以配置在ngnix上，前后端都不需要额外的操作。 缺点：仅支持高版本的浏览器 Ngnix的代理通过Ngnix进行请求代理的转发，在服务器端就不存在跨域了，通过配置proxy_pass转发。网易163邮箱和126邮箱的登录就是通过该方法。 Flash跨域Flash的跨域和iframe的跨域方式差不多，都是通过代理文件实现的，目前flash方式用的比较少了。 总结1.在少量的跨域请求时可以用JSONP的方式。2.能利用Ngnix代理则利用Ngnix代理配置进行转发，目前很多前后端分离的项目，前端单独服务器部署，本身就用到了Ngnix的代理转发到后端。3.在移动端和仅需要支持版本浏览器的时候使用CORS跨域方案。4.需要支持IE8以下的低版本浏览器的时候使用iframe方式。","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"reqwest源码学习","date":"2017-07-22T10:50:10.000Z","path":"2017/07/22/reqwest/","text":"最近的几个项目都用了reqwest，空闲时间看了下reqwest源码，覆上了自己理解的注释(文中@jch为个人注解)。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645/*! * Reqwest! A general purpose XHR connection manager * license MIT (c) Dustin Diaz 2015 * https://github.com/ded/reqwest */!function (name, context, definition) &#123; if (typeof module != 'undefined' &amp;&amp; module.exports) module.exports = definition() else if (typeof define == 'function' &amp;&amp; define.amd) define(definition) else context[name] = definition()&#125;('reqwest', this, function () &#123; var context = this if ('window' in context) &#123; var doc = document , byTag = 'getElementsByTagName' , head = doc[byTag]('head')[0] &#125; else &#123; var XHR2 try &#123; XHR2 = require('xhr2') &#125; catch (ex) &#123; throw new Error('Peer dependency `xhr2` required! Please npm install xhr2') &#125; &#125; var httpsRe = /^http/ , protocolRe = /(^\\w+):\\/\\// , twoHundo = /^(20\\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request , readyState = 'readyState' , contentType = 'Content-Type' , requestedWith = 'X-Requested-With' , uniqid = 0 , callbackPrefix = 'reqwest_' + (+new Date()) , lastValue // data stored by the most recent JSONP callback , xmlHttpRequest = 'XMLHttpRequest' , xDomainRequest = 'XDomainRequest' , noop = function () &#123;&#125; , isArray = typeof Array.isArray == 'function' ? Array.isArray : function (a) &#123; return a instanceof Array &#125; , defaultHeaders = &#123; 'contentType': 'application/x-www-form-urlencoded' , 'requestedWith': xmlHttpRequest , 'accept': &#123; '*': 'text/javascript, text/html, application/xml, text/xml, */*' , 'xml': 'application/xml, text/xml' , 'html': 'text/html' , 'text': 'text/plain' , 'json': 'application/json, text/javascript' , 'js': 'application/javascript, text/javascript' &#125; &#125; , xhr = function(o) &#123; // is it x-domain if (o['crossOrigin'] === true) &#123; var xhr = context[xmlHttpRequest] ? new XMLHttpRequest() : null if (xhr &amp;&amp; 'withCredentials' in xhr) &#123; return xhr &#125; else if (context[xDomainRequest]) &#123; return new XDomainRequest() &#125; else &#123; throw new Error('Browser does not support cross-origin requests') &#125; &#125; else if (context[xmlHttpRequest]) &#123; return new XMLHttpRequest() &#125; else if (XHR2) &#123; return new XHR2() &#125; else &#123; return new ActiveXObject('Microsoft.XMLHTTP') &#125; &#125; , globalSetupOptions = &#123; dataFilter: function (data) &#123; return data &#125; &#125; function succeed(r) &#123; var protocol = protocolRe.exec(r.url) protocol = (protocol &amp;&amp; protocol[1]) || context.location.protocol return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response &#125; function handleReadyState(r, success, error) &#123; return function () &#123; // use _aborted to mitigate against IE err c00c023f // (can't read props on aborted request objects) if (r._aborted) return error(r.request) if (r._timedOut) return error(r.request, 'Request is aborted: timeout') if (r.request &amp;&amp; r.request[readyState] == 4) &#123; r.request.onreadystatechange = noop if (succeed(r)) &#123; success(r.request) // @jch 这里调用success的方法的时候将xhr对象给传过去了，当然包括了xhr.status http code的状态码 &#125; else error(r.request) // @jch error的时候也返回了xhr.status &#125; &#125; &#125; function setHeaders(http, o) &#123; var headers = o['headers'] || &#123;&#125; , h headers['Accept'] = headers['Accept'] || defaultHeaders['accept'][o['type']] || defaultHeaders['accept']['*'] var isAFormData = typeof FormData !== 'undefined' &amp;&amp; (o['data'] instanceof FormData); // breaks cross-origin requests with legacy browsers if (!o['crossOrigin'] &amp;&amp; !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith'] if (!headers[contentType] &amp;&amp; !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType'] for (h in headers) headers.hasOwnProperty(h) &amp;&amp; 'setRequestHeader' in http &amp;&amp; http.setRequestHeader(h, headers[h]) &#125; function setCredentials(http, o) &#123; if (typeof o['withCredentials'] !== 'undefined' &amp;&amp; typeof http.withCredentials !== 'undefined') &#123; http.withCredentials = !!o['withCredentials'] &#125; &#125; function generalCallback(data) &#123; lastValue = data &#125; function urlappend (url, s) &#123; return url + (/\\?/.test(url) ? '&amp;' : '?') + s &#125; function handleJsonp(o, fn, err, url) &#123; var reqId = uniqid++ , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId) , cbreg = new RegExp('((^|\\\\?|&amp;)' + cbkey + ')=([^&amp;]+)') , match = url.match(cbreg) , script = doc.createElement('script') , loaded = 0 , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1 if (match) &#123; if (match[3] === '?') &#123; url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name &#125; else &#123; cbval = match[3] // provided callback func name &#125; &#125; else &#123; url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em &#125; context[cbval] = generalCallback script.type = 'text/javascript' script.src = url script.async = true if (typeof script.onreadystatechange !== 'undefined' &amp;&amp; !isIE10) &#123; // need this for IE due to out-of-order onreadystatechange(), binding script // execution to an event listener gives us control over when the script // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html script.htmlFor = script.id = '_reqwest_' + reqId &#125; script.onload = script.onreadystatechange = function () &#123; if ((script[readyState] &amp;&amp; script[readyState] !== 'complete' &amp;&amp; script[readyState] !== 'loaded') || loaded) &#123; return false &#125; script.onload = script.onreadystatechange = null script.onclick &amp;&amp; script.onclick() // Call the user callback with the last value stored and clean up values and scripts. fn(lastValue) lastValue = undefined head.removeChild(script) loaded = 1 &#125; // Add the script to the DOM head head.appendChild(script) // Enable JSONP timeout return &#123; abort: function () &#123; script.onload = script.onreadystatechange = null err(&#123;&#125;, 'Request is aborted: timeout', &#123;&#125;) lastValue = undefined head.removeChild(script) loaded = 1 &#125; &#125; &#125; function getRequest(fn, err) &#123; var o = this.o , method = (o['method'] || 'GET').toUpperCase() , url = typeof o === 'string' ? o : o['url'] // convert non-string objects to query-string form unless o['processData'] is false , data = (o['processData'] !== false &amp;&amp; o['data'] &amp;&amp; typeof o['data'] !== 'string') ? reqwest.toQueryString(o['data']) : (o['data'] || null) , http , sendWait = false // if we're working on a GET request and we have data then we should append // query string to end of URL and not post data if ((o['type'] == 'jsonp' || method == 'GET') &amp;&amp; data) &#123; url = urlappend(url, data) data = null &#125; if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url) // get the xhr from the factory if passed // if the factory returns null, fall-back to ours http = (o.xhr &amp;&amp; o.xhr(o)) || xhr(o) http.open(method, url, o['async'] === false ? false : true) setHeaders(http, o) setCredentials(http, o) if (context[xDomainRequest] &amp;&amp; http instanceof context[xDomainRequest]) &#123; http.onload = fn http.onerror = err // NOTE: see // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e http.onprogress = function() &#123;&#125; sendWait = true &#125; else &#123; http.onreadystatechange = handleReadyState(this, fn, err) &#125; o['before'] &amp;&amp; o['before'](http) if (sendWait) &#123; setTimeout(function () &#123; http.send(data) &#125;, 200) &#125; else &#123; http.send(data) &#125; return http &#125; function Reqwest(o, fn) &#123; this.o = o this.fn = fn init.apply(this, arguments) &#125; function setType(header) &#123; // json, javascript, text/plain, text/html, xml if (header === null) return undefined; //In case of no content-type. if (header.match('json')) return 'json' if (header.match('javascript')) return 'js' if (header.match('text')) return 'html' if (header.match('xml')) return 'xml' &#125; function init(o, fn) &#123; this.url = typeof o == 'string' ? o : o['url'] this.timeout = null // whether request has been fulfilled for purpose // of tracking the Promises this._fulfilled = false // success handlers this._successHandler = function()&#123;&#125; this._fulfillmentHandlers = [] // error handlers this._errorHandlers = [] // complete (both success and fail) handlers this._completeHandlers = [] this._erred = false this._responseArgs = &#123;&#125; var self = this fn = fn || function () &#123;&#125; if (o['timeout']) &#123; this.timeout = setTimeout(function () &#123; timedOut() &#125;, o['timeout']) &#125; if (o['success']) &#123; this._successHandler = function () &#123; o['success'].apply(o, arguments) &#125; &#125; if (o['error']) &#123; this._errorHandlers.push(function () &#123; o['error'].apply(o, arguments) &#125;) &#125; if (o['complete']) &#123; this._completeHandlers.push(function () &#123; o['complete'].apply(o, arguments) &#125;) &#125; function complete (resp) &#123; o['timeout'] &amp;&amp; clearTimeout(self.timeout) self.timeout = null while (self._completeHandlers.length &gt; 0) &#123; self._completeHandlers.shift()(resp) &#125; &#125; function success (resp) &#123; var type = o['type'] || resp &amp;&amp; setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE resp = (type !== 'jsonp') ? self.request : resp // use global data filter on response text var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type) , r = filteredResponse // @jch filteredResponse 这里传入的type 为json， globalSetupOptions.dataFilter传入的时候 // 就已经是resp.responseText， 过滤掉了xhr.status. try &#123; resp.responseText = r &#125; catch (e) &#123; // can't assign this in IE&lt;=8, just ignore &#125; if (r) &#123; switch (type) &#123; case 'json': try &#123; resp = context.JSON ? context.JSON.parse(r) : eval('(' + r + ')') // @jch 这里帮处理JSON.parse的转换，所以外面我们success, error接受到的就是对象 &#125; catch (err) &#123; return error(resp, 'Could not parse JSON in response', err) &#125; break case 'js': resp = eval(r) break case 'html': resp = r break case 'xml': resp = resp.responseXML &amp;&amp; resp.responseXML.parseError // IE trololo &amp;&amp; resp.responseXML.parseError.errorCode &amp;&amp; resp.responseXML.parseError.reason ? null : resp.responseXML break &#125; &#125; self._responseArgs.resp = resp self._fulfilled = true fn(resp) self._successHandler(resp) // @jch 这里就是调用传入的success函数处理 while (self._fulfillmentHandlers.length &gt; 0) &#123; resp = self._fulfillmentHandlers.shift()(resp) &#125; complete(resp) // @jch 先进入的success处理完之后，才是调用complete函数 &#125; function timedOut() &#123; self._timedOut = true self.request.abort() &#125; function error(resp, msg, t) &#123; resp = self.request self._responseArgs.resp = resp self._responseArgs.msg = msg self._responseArgs.t = t self._erred = true while (self._errorHandlers.length &gt; 0) &#123; self._errorHandlers.shift()(resp, msg, t) // @jch // _errorHandlers的就是 调用外面出入的error函数，这里的resp就包括了xhr.status. // 但是测试 接口404的时候status并没有返回404， 而是返回的为0，难道拿不到httpCode? // 但是成功的http 200Code拿到了，在succeed 函数里就是根据r.request.status == 20\\d来判断的 // 百度搜到了这status 返回0的情况：http://blog.csdn.net/iaiti/article/details/42192659 // 我的测试情况是 跨域访问了nei的接口，但是nei里面没有这个接口，浏览器就禁止跨域访问了， // 所以还没有到返回http code的情况. // 哈哈哈，原来是这个跨域的问题，所以我不使用nei了，而是使用了http-proxy-middleware这个插件给我代理发送到nei mock数据那里， // 它这个代理相对于你本地起了一个后端服务，这个后端服务帮你转发了请求，所以不是跨域问题，所以这样成功的拿到了404的code. // 所以这里reqwest在http code不是20\\d的情况下，传给error的时候是返回了xhr.status, httpCode的，外层也是可以拿到的 &#125; complete(resp) &#125; this.request = getRequest.call(this, success, error) &#125; Reqwest.prototype = &#123; abort: function () &#123; this._aborted = true this.request.abort() &#125; , retry: function () &#123; init.call(this, this.o, this.fn) &#125; /** * Small deviation from the Promises A CommonJs specification * http://wiki.commonjs.org/wiki/Promises/A */ /** * `then` will execute upon successful requests */ , then: function (success, fail) &#123; success = success || function () &#123;&#125; fail = fail || function () &#123;&#125; if (this._fulfilled) &#123; this._responseArgs.resp = success(this._responseArgs.resp) &#125; else if (this._erred) &#123; fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t) &#125; else &#123; this._fulfillmentHandlers.push(success) this._errorHandlers.push(fail) &#125; return this &#125; /** * `always` will execute whether the request succeeds or fails */ , always: function (fn) &#123; if (this._fulfilled || this._erred) &#123; fn(this._responseArgs.resp) &#125; else &#123; this._completeHandlers.push(fn) &#125; return this &#125; /** * `fail` will execute when the request fails */ , fail: function (fn) &#123; if (this._erred) &#123; fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t) &#125; else &#123; this._errorHandlers.push(fn) &#125; return this &#125; , 'catch': function (fn) &#123; return this.fail(fn) &#125; &#125; function reqwest(o, fn) &#123; return new Reqwest(o, fn) &#125; // normalize newline variants according to spec -&gt; CRLF function normalize(s) &#123; return s ? s.replace(/\\r?\\n/g, '\\r\\n') : '' &#125; function serial(el, cb) &#123; var n = el.name , t = el.tagName.toLowerCase() , optCb = function (o) &#123; // IE gives value=\"\" even where there is no value attribute // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273 if (o &amp;&amp; !o['disabled']) cb(n, normalize(o['attributes']['value'] &amp;&amp; o['attributes']['value']['specified'] ? o['value'] : o['text'])) &#125; , ch, ra, val, i // don't serialize elements that are disabled or without a name if (el.disabled || !n) return switch (t) &#123; case 'input': if (!/reset|button|image|file/i.test(el.type)) &#123; ch = /checkbox/i.test(el.type) ra = /radio/i.test(el.type) val = el.value // WebKit gives us \"\" instead of \"on\" if a checkbox has no value, so correct it here ;(!(ch || ra) || el.checked) &amp;&amp; cb(n, normalize(ch &amp;&amp; val === '' ? 'on' : val)) &#125; break case 'textarea': cb(n, normalize(el.value)) break case 'select': if (el.type.toLowerCase() === 'select-one') &#123; optCb(el.selectedIndex &gt;= 0 ? el.options[el.selectedIndex] : null) &#125; else &#123; for (i = 0; el.length &amp;&amp; i &lt; el.length; i++) &#123; el.options[i].selected &amp;&amp; optCb(el.options[i]) &#125; &#125; break &#125; &#125; // collect up all form elements found from the passed argument elements all // the way down to child elements; pass a '&lt;form&gt;' or form fields. // called with 'this'=callback to use for serial() on each element function eachFormElement() &#123; var cb = this , e, i , serializeSubtags = function (e, tags) &#123; var i, j, fa for (i = 0; i &lt; tags.length; i++) &#123; fa = e[byTag](tags[i]) for (j = 0; j &lt; fa.length; j++) serial(fa[j], cb) &#125; &#125; for (i = 0; i &lt; arguments.length; i++) &#123; e = arguments[i] if (/input|select|textarea/i.test(e.tagName)) serial(e, cb) serializeSubtags(e, [ 'input', 'select', 'textarea' ]) &#125; &#125; // standard query string style serialization function serializeQueryString() &#123; return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments)) &#125; // &#123; 'name': 'value', ... &#125; style serialization function serializeHash() &#123; var hash = &#123;&#125; eachFormElement.apply(function (name, value) &#123; if (name in hash) &#123; hash[name] &amp;&amp; !isArray(hash[name]) &amp;&amp; (hash[name] = [hash[name]]) hash[name].push(value) &#125; else hash[name] = value &#125;, arguments) return hash &#125; // [ &#123; name: 'name', value: 'value' &#125;, ... ] style serialization reqwest.serializeArray = function () &#123; var arr = [] eachFormElement.apply(function (name, value) &#123; arr.push(&#123;name: name, value: value&#125;) &#125;, arguments) return arr &#125; reqwest.serialize = function () &#123; if (arguments.length === 0) return '' var opt, fn , args = Array.prototype.slice.call(arguments, 0) opt = args.pop() opt &amp;&amp; opt.nodeType &amp;&amp; args.push(opt) &amp;&amp; (opt = null) opt &amp;&amp; (opt = opt.type) if (opt == 'map') fn = serializeHash else if (opt == 'array') fn = reqwest.serializeArray else fn = serializeQueryString return fn.apply(null, args) &#125; reqwest.toQueryString = function (o, trad) &#123; var prefix, i , traditional = trad || false , s = [] , enc = encodeURIComponent , add = function (key, value) &#123; // If value is a function, invoke it and return its value value = ('function' === typeof value) ? value() : (value == null ? '' : value) s[s.length] = enc(key) + '=' + enc(value) &#125; // If an array was passed in, assume that it is an array of form elements. if (isArray(o)) &#123; for (i = 0; o &amp;&amp; i &lt; o.length; i++) add(o[i]['name'], o[i]['value']) &#125; else &#123; // If traditional, encode the \"old\" way (the way 1.3.2 or older // did it), otherwise encode params recursively. for (prefix in o) &#123; if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add) &#125; &#125; // spaces should be + according to spec return s.join('&amp;').replace(/%20/g, '+') &#125; function buildParams(prefix, obj, traditional, add) &#123; var name, i, v , rbracket = /\\[\\]$/ if (isArray(obj)) &#123; // Serialize array item. for (i = 0; obj &amp;&amp; i &lt; obj.length; i++) &#123; v = obj[i] if (traditional || rbracket.test(prefix)) &#123; // Treat each array item as a scalar. add(prefix, v) &#125; else &#123; buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add) &#125; &#125; &#125; else if (obj &amp;&amp; obj.toString() === '[object Object]') &#123; // Serialize object item. for (name in obj) &#123; buildParams(prefix + '[' + name + ']', obj[name], traditional, add) &#125; &#125; else &#123; // Serialize scalar item. add(prefix, obj) &#125; &#125; reqwest.getcallbackPrefix = function () &#123; return callbackPrefix &#125; // jQuery and Zepto compatibility, differences can be remapped here so you can call // .ajax.compat(options, callback) reqwest.compat = function (o, fn) &#123; if (o) &#123; o['type'] &amp;&amp; (o['method'] = o['type']) &amp;&amp; delete o['type'] o['dataType'] &amp;&amp; (o['type'] = o['dataType']) o['jsonpCallback'] &amp;&amp; (o['jsonpCallbackName'] = o['jsonpCallback']) &amp;&amp; delete o['jsonpCallback'] o['jsonp'] &amp;&amp; (o['jsonpCallback'] = o['jsonp']) &#125; return new Reqwest(o, fn) &#125; reqwest.ajaxSetup = function (options) &#123; options = options || &#123;&#125; for (var k in options) &#123; globalSetupOptions[k] = options[k] &#125; &#125; return reqwest&#125;);","tags":[]},{"title":"新年初始","date":"2017-01-02T11:09:00.000Z","path":"2017/01/02/2017新年初始/","text":"搭建起了自己的博客，记录生活的点滴，时间过的太快，我怕记忆跟随不上脚步。。。","tags":[]}]